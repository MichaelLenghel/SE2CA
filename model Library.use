model Library

class Book
	attributes
		title : String
		author : String
		no_copies : Integer
		no_onshelf : Integer
	operations
		borrow()
		begin
		 self.no_onshelf := self.no_onshelf - 1
		end
		pre copiesOnShelf: no_copies > 0
		post: no_onshelf = no_onshelf@pre - 1
		return()
		begin
			self.no_onshelf := self.no_onshelf + 1
		end
		post: no_onshelf = no_onshelf@pre + 1
		reserve()
		begin
			self.no_onshelf := self.no_onshelf - 1
		end
		pre copiesOnShelf: no_copies > 0

	--statemachines
		--psm States
		--states
			--newTitle : initial
			--available [no_onshelf > 0]
			--unavailable [no_onshelf = 0]
		--transitions
			--newTitle -> available { create }
			--available -> unavailable { [no_onshelf = 1] borrow() }
			--available -> available { [no_onshelf > 1] borrow() }
			--available -> available { return() }
			--unavailable -> available { return() }
		--end

end
	class Copy
		attributes
		status : String init = 'onShelf'
		operations
		borrow( m : Member)
		begin
			self.status := 'onLoan';
			self.book.borrow()
 		end
 		return( m : Member)
 		begin
 			self.status := 'onShelf';
 			self.book.return()
 		end
 		reserve( m : Member)
 		begin
 			self.status := 'reserved';
 			self.book.reserve()
 		end
end


class Member
	attributes
		name : String
		address : String
		no_onloan : Integer init = 0
		no_reserved : Integer init = 0
		status : String
		--Memebrship can expire
		validMember : String init = 'valid'
		fine : Integer init = 0
	operations
		borrow(c : Copy)
		begin
			insert (self, c) into HasBorrowed;
			self.no_onloan := self.no_onloan + 1;
			c.borrow(self)
		end
		return(c : Copy)
		begin
			delete (self, c) from HasBorrowed;
			self.no_onloan := self.no_onloan - 1;
			c.return(self)
		end
		reserve(c : Copy)
		begin
			insert (self, c) into IsReserved;
			self.no_reserved := self.no_reserved + 1;
			c.reserve(self)
		end
		borrowReserved(c : Copy)
		begin
			self.no_reserved := self.no_reserved - 1;
			delete (self, c) from IsReserved;
			insert (self, c) into HasBorrowed;
			self.no_onloan := self.no_onloan + 1;
			c.borrow(self)
		end
		cancelReservation(c : Copy)
		begin
			delete (self, c) from IsReserved;
			self.no_reserved := self.no_reserved - 1;
			--We can call return and not an independant cancel fxn as it's contents are the exact same
			c.return(self)
		end
		overDue(c : Copy)
end

association HasBorrowed between
	Member[0..1] role borrower
	Copy[*] role borrowed
end
association CopyOf between
	Copy[1..*] role copies
	Book[1] role book
end
association IsReserved between
	Member[0..1] role reserver
	Copy[*] role reserved
end

constraints
context Member::borrow(c:Copy)
	pre limit: self.no_onloan < 1
	pre cond1: self.borrowed->excludes(c)
	pre borrowIfAvailable: c.status = 'onShelf'
	post cond2: self.borrowed->includes(c)

context Member::return(c:Copy)
	pre cond1: self.borrowed->includes(c)
	post cond2: self.borrowed->excludes(c)

context Member::reserve(c:Copy)
	pre cond1: self.reserved->excludes(c)
	pre borrowIfAvailable: c.status = 'onShelf'
	pre noOverDuebooks: self.status <> 'overDue'
	pre limit: self.no_reserved < 1
	post cond2: self.reserved->includes(c)

context Member::borrowReserved(c:Copy)
	pre cond1: self.reserved->includes(c)
	post con2: self.reserved->excludes(c)

context Member::cancelReservation(c:Copy)
	pre cond1: self.reserved->includes(c)
	post con2: self.reserved->excludes(c)

context Member::overDue(c:Copy)
	--Must be borrowed to be overdue
	pre cond1: self.borrowed->includes(c)
	--Can't already be overdue
	post setFine: self.fine > 0



context Member inv: self.validMember = 'valid'
--context Member inv: self.status <> 'overDue'

